---
import { encrypt } from "@/utils/encrypt";
import "@/styles/password.css";

export interface Props {
  password: string;
  passwordSubtitle?: string;
}

const { password, passwordSubtitle = "请输入密码以查看内容" } = Astro.props;

const html = await Astro.slots.render("default");
const encryptedHtml = await encrypt(html, password);
---

<meta name="encrypted" content={encryptedHtml} />
<meta name="robots" content="noindex, nofollow" />
<meta name="starlight:search" content="exclude" />

<div id="encryption" class="password-container" data-search-exclude="true" data-noindex="true" style="display: none !important; visibility: hidden !important; opacity: 0 !important;">
  <!-- 锁图标 -->
  <div class="password-icon">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
    </svg>
  </div>

  <!-- 标题 -->
  <h2 class="password-title">该笔记已加密</h2>
  <p class="password-subtitle">{passwordSubtitle}</p>

  <!-- 密码输入框容器 -->
  <div class="password-input-wrapper">
    <input
      id="password"
      class="password-input"
      placeholder="请输入密码"
      type="password"
      autocomplete="off"
      autofocus
    />
    <!-- 眼睛图标按钮 -->
    <button
      id="password-toggle"
      class="password-toggle"
      type="button"
      aria-label="切换密码显示"
    >
      <!-- 眼睛图标 - 默认显示（密码隐藏时） -->
      <svg id="eye-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
        <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
        <path stroke-linecap="round" stroke-linejoin="round" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
      </svg>
      <!-- 眼睛斜线图标 - 密码显示时 -->
      <svg id="eye-off-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" style="display: none;">
        <path stroke-linecap="round" stroke-linejoin="round" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.29 3.29m0 0L3 3m3.29 3.29L12 12m-5.71-5.71L12 12" />
      </svg>
    </button>
  </div>

  <!-- 解锁按钮 -->
  <button
    id="password-btn"
    class="password-button"
    type="button"
  >
    解锁文章
  </button>

  <!-- 错误提示元素 -->
  <div id="error-message" class="password-error" style="display: none;">
    密码错误，请重新输入。
  </div>
</div>

<script is:inline data-astro-rerun>
  // 在页面加载的最早时机检查是否有保存的密码，如果有则立即隐藏加密界面
  (function() {
    const key = window.location.pathname;
    function getItemWithExpire(key) {
      try {
        const itemStr = localStorage.getItem(key);
        if (!itemStr) return null;
        const item = JSON.parse(itemStr);
        if (new Date().getTime() > item.expire) {
          localStorage.removeItem(key);
          return null;
        }
        return item.value;
      } catch {
        return null;
      }
    }
    
    // 立即检查是否有保存的密码
    const savedPassword = getItemWithExpire(key);
    const encryption = document.getElementById("encryption");
    
    if (savedPassword) {
      // 如果有保存的密码，保持隐藏状态（初始就是隐藏的）
      // 不需要做任何操作，加密界面会保持隐藏
    } else {
      // 如果没有保存的密码，显示加密界面
      if (encryption) {
        encryption.classList.add("show");
        encryption.style.cssText = `
          display: flex !important;
          flex-direction: column !important;
          align-items: center !important;
          justify-content: center !important;
          min-height: 400px !important;
          padding: 2rem !important;
          text-align: center !important;
          visibility: visible !important;
          opacity: 1 !important;
          width: 100% !important;
        `;
      }
    }
  })();

  /**
   * Base64 解码函数（替代已弃用的 atob）
   *
   * @param base64 Base64 字符串
   * @returns Uint8Array
   */
  function base64ToUint8(base64) {
    // 移除空白字符
    const cleanBase64 = base64.replace(/\s/g, "");
    const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    // 计算输出长度（考虑填充）
    const padding = (cleanBase64.match(/=/g) || []).length;
    const outputLength = Math.floor((cleanBase64.length * 3) / 4) - padding;
    const result = new Uint8Array(outputLength);
    let resultIndex = 0;
    
    for (let i = 0; i < cleanBase64.length; i += 4) {
      const enc1 = base64Chars.indexOf(cleanBase64.charAt(i));
      const enc2 = base64Chars.indexOf(cleanBase64.charAt(i + 1));
      const enc3 = cleanBase64.charAt(i + 2) === "=" ? -1 : base64Chars.indexOf(cleanBase64.charAt(i + 2));
      const enc4 = cleanBase64.charAt(i + 3) === "=" ? -1 : base64Chars.indexOf(cleanBase64.charAt(i + 3));
      
      const bitmap = (enc1 << 18) | (enc2 << 12) | 
                     ((enc3 >= 0 ? enc3 : 0) << 6) | 
                     (enc4 >= 0 ? enc4 : 0);
      
      if (resultIndex < result.length) result[resultIndex++] = (bitmap >> 16) & 255;
      if (resultIndex < result.length && enc3 >= 0) result[resultIndex++] = (bitmap >> 8) & 255;
      if (resultIndex < result.length && enc4 >= 0) result[resultIndex++] = bitmap & 255;
    }
    return result;
  }

  /**
   * 异步解密函数
   *
   * @param data Base64 加密字符串
   * @param key 密码
   *
   * @returns 解密后的明文字符串
   */
  async function decrypt(data, key) {
    key = key.padEnd(16, "0"); // AES-CBC key 补齐 16 字节
    // 使用现代方法替代已弃用的 atob
    const dataBuffer = base64ToUint8(data);
    const keyBuffer = new TextEncoder().encode(key);
    const cryptoKey = await crypto.subtle.importKey(
      "raw",
      keyBuffer,
      { name: "AES-CBC", length: 256 },
      false,
      ["decrypt"]
    );
    const iv = dataBuffer.slice(0, 16);
    const encryptedData = dataBuffer.slice(16);
    const decryptedData = await crypto.subtle.decrypt(
      { name: "AES-CBC", iv },
      cryptoKey,
      encryptedData
    );
    return new TextDecoder().decode(new Uint8Array(decryptedData));
  }

  /**
   * 初始化页面解密逻辑
   */
  function prepare() {
    // 检查是否已经初始化过（避免重复绑定）
    if (document.getElementById("encryption")?.dataset.initialized === "true") {
      return;
    }

    const encrypted = document
      .querySelector("meta[name=encrypted]")?.getAttribute("content");
    const input = document.getElementById("password");
    const btn = document.getElementById("password-btn");
    const article = document.querySelector("#encryption");
    const key = window.location.pathname;
    const errorMessage = document.getElementById("error-message");
    const toggleBtn = document.getElementById("password-toggle");
    const eyeIcon = document.getElementById("eye-icon");
    const eyeOffIcon = document.getElementById("eye-off-icon");

    if (!input || !btn || !article) return;

    // 标记为已初始化
    article.dataset.initialized = "true";
    
    // 确保输入框和按钮可以正常交互
    input.disabled = false;
    input.readOnly = false;
    btn.disabled = false;
    input.style.pointerEvents = "auto";
    btn.style.pointerEvents = "auto";

    // 检查是否有保存的密码，如果没有则显示加密界面
    const hasSavedPassword = getItemWithExpire(key);
    if (!hasSavedPassword) {
      // 如果没有保存的密码，显示加密界面
      article.classList.add("show");
      article.style.cssText = `
        display: flex !important;
        flex-direction: column !important;
        align-items: center !important;
        justify-content: center !important;
        min-height: 400px !important;
        padding: 2rem !important;
        text-align: center !important;
        visibility: visible !important;
        opacity: 1 !important;
        width: 100% !important;
      `;
    }

    // 隐藏目录（Table of Contents）的函数
    const hideTOC = () => {
      // 确保不会隐藏密码容器本身
      const encryptionElement = document.getElementById("encryption");
      if (!encryptionElement) return;
      
      // 使用更简单直接的方式：查找所有右侧的 aside 元素
      const allAsides = document.querySelectorAll('aside');
      allAsides.forEach(aside => {
        // 确保不隐藏密码容器或其子元素
        if (aside === encryptionElement || encryptionElement.contains(aside) || aside.contains(encryptionElement)) {
          return;
        }
        // 跳过主内容区域的 aside
        if (aside.closest('#encryption') || aside.closest('main') || aside.closest('article')) {
          return;
        }
        
        const rect = aside.getBoundingClientRect();
        // 如果是右侧边栏（通常在页面右侧 60% 之后）
        if (rect.left > window.innerWidth * 0.6 && rect.width > 0) {
          const ariaLabel = aside.getAttribute('aria-label') || '';
          const hasTOCContent = 
            ariaLabel.includes('本页内容') ||
            ariaLabel.includes('On this page') ||
            ariaLabel.includes('Content') ||
            aside.classList.contains('sl-sidebar-toc') ||
            aside.hasAttribute('data-sidebar-toc') ||
            aside.querySelector('nav[aria-label*="本页内容"]') ||
            aside.querySelector('nav[aria-label*="On this page"]');
          
          if (hasTOCContent || rect.left > window.innerWidth * 0.7) {
            aside.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; height: 0 !important; overflow: hidden !important; pointer-events: none !important;';
            aside.setAttribute('data-encrypted-hidden', 'true');
          }
        }
      });
    };

    // 确保页面标题居中的函数
    const centerPageTitle = () => {
      const pageTitle = document.querySelector("h1");
      if (pageTitle && article.classList.contains("password-container")) {
        pageTitle.style.textAlign = "center";
      }
    };

    // 阻止搜索索引加密内容
    const excludeFromSearch = () => {
      // 标记整个页面为不可搜索
      document.documentElement.setAttribute('data-search-exclude', 'true');
      // 移除可能的搜索索引数据
      if (window.starlightSearchIndex) {
        // 如果存在搜索索引，标记当前页面
        const currentPath = window.location.pathname;
        if (window.starlightSearchIndex.pages) {
          window.starlightSearchIndex.pages = window.starlightSearchIndex.pages.filter(
            page => page.url !== currentPath
          );
        }
      }
      // 阻止搜索组件索引当前页面
      const searchInputs = document.querySelectorAll('input[type="search"], input[placeholder*="搜索"], input[placeholder*="Search"]');
      searchInputs.forEach(input => {
        input.setAttribute('data-exclude-page', window.location.pathname);
      });
    };

    // 确保密码容器可见
    article.style.display = "flex";
    article.style.visibility = "visible";
    article.style.opacity = "1";

    // 立即执行
    hideTOC();
    centerPageTitle();
    excludeFromSearch();

    // 持续确保密码容器可见的函数
    const keepVisible = () => {
      if (article && article.classList.contains("password-container")) {
        article.style.cssText = `
          display: flex !important;
          flex-direction: column !important;
          align-items: center !important;
          justify-content: center !important;
          min-height: 400px !important;
          padding: 2rem !important;
          text-align: center !important;
          visibility: visible !important;
          opacity: 1 !important;
          width: 100% !important;
        `;
      }
    };

    // 使用 MutationObserver 监听 DOM 变化，确保目录被隐藏，同时保持密码容器可见
    let observerTimeout;
    const observer = new MutationObserver(() => {
      // 防抖处理，避免频繁执行
      clearTimeout(observerTimeout);
      observerTimeout = setTimeout(() => {
        if (article.classList.contains("password-container")) {
          keepVisible(); // 优先确保密码容器可见
          hideTOC();
          centerPageTitle();
        }
      }, 50);
    });
    observer.observe(document.body, { childList: true, subtree: false }); // 只监听直接子元素，减少性能开销
    
    // 只在需要时检查目录（减少频率）
    let hideTOCInterval;
    const startTOCCheck = () => {
      if (hideTOCInterval) return; // 避免重复启动
      hideTOCInterval = setInterval(() => {
        if (article.classList.contains("password-container")) {
          keepVisible();
          hideTOC();
        } else {
          clearInterval(hideTOCInterval);
          hideTOCInterval = null;
        }
      }, 500); // 降低频率到 500ms
    };
    startTOCCheck();

    // 初始化密码显示/隐藏切换
    if (eyeIcon && eyeOffIcon && toggleBtn && !toggleBtn.dataset.bound) {
      toggleBtn.dataset.bound = "true";
      toggleBtn.addEventListener("click", () => {
        if (input.type === "password") {
          input.type = "text";
          eyeIcon.style.display = "none";
          eyeOffIcon.style.display = "block";
        } else {
          input.type = "password";
          eyeIcon.style.display = "block";
          eyeOffIcon.style.display = "none";
        }
      });
    }

    // 回车键提交
    input.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        btn.click();
      }
    });

    // 解密按钮点击事件
    let isDecrypting = false;
    btn.addEventListener("click", async () => {
      if (isDecrypting) return;
      
      const password = input.value;
      if (!password) {
        if (errorMessage) {
          errorMessage.textContent = "请输入密码";
          errorMessage.style.display = "block";
        }
        return;
      }

      isDecrypting = true;
      btn.disabled = true;
      btn.textContent = "解锁中...";

      try {
        const html = await decrypt(encrypted, password);
        
        // 停止所有监控和定时器，避免干扰和残影
        if (observer) observer.disconnect();
        if (hideTOCInterval) {
          clearInterval(hideTOCInterval);
          hideTOCInterval = null;
        }
        
        // 移除密码容器的样式类，恢复为正常内容容器
        article.classList.remove("password-container");
        // 移除搜索排除标记
        article.removeAttribute("data-search-exclude");
        article.removeAttribute("data-noindex");
        // 重置所有内联样式，让内容使用默认的 Starlight 样式
        article.style.cssText = "";
        article.innerHTML = html;
        
        // 恢复目录显示 - 完全清除样式
        const hiddenElements = document.querySelectorAll('[data-encrypted-hidden="true"]');
        hiddenElements.forEach(el => {
          el.style.cssText = ""; // 使用 cssText 完全清除所有样式
          el.removeAttribute('data-encrypted-hidden');
        });
        
        // 恢复页面标题左对齐
        const pageTitle = document.querySelector("h1");
        if (pageTitle) {
          pageTitle.style.textAlign = "";
        }
        
        // 移除 noindex meta 标签
        const noindexMeta = document.querySelector("meta[name='robots'][content*='noindex']");
        if (noindexMeta) {
          noindexMeta.setAttribute("content", "index, follow");
        }
        
        // 移除搜索排除标记
        document.documentElement.removeAttribute('data-search-exclude');
        const searchExcludeMeta = document.querySelector("meta[name='starlight:search']");
        if (searchExcludeMeta) {
          searchExcludeMeta.remove();
        }
        
        setItemWithExpire(key, password, 86400);
        if (errorMessage) {
          errorMessage.style.display = "none";
        }
      } catch {
        if (errorMessage) {
          errorMessage.textContent = "密码错误，请重新输入。";
          errorMessage.style.display = "block";
        }
        btn.disabled = false;
        btn.textContent = "解锁文章";
        input.value = "";
        input.focus();
      } finally {
        isDecrypting = false;
      }
    });

    // 自动解密：如果有保存的密码，立即解密（避免显示加密界面）
    const autoDecryptPassword = getItemWithExpire(key);
    if (autoDecryptPassword && encrypted) {
      // 加密界面应该已经在脚本开头被隐藏了，这里确保隐藏（双重保险）
      article.style.opacity = "0";
      article.style.visibility = "hidden";
      article.style.transition = "none";
      
      // 立即执行解密，不等待
      (async () => {
        try {
          const html = await decrypt(encrypted, autoDecryptPassword);
          // 移除密码容器的样式类，恢复为正常内容容器
          article.classList.remove("password-container");
          // 移除搜索排除标记
          article.removeAttribute("data-search-exclude");
          article.removeAttribute("data-noindex");
          // 重置所有内联样式，让内容使用默认的 Starlight 样式
          article.style.cssText = "";
          article.style.opacity = "1";
          article.style.visibility = "visible";
          article.innerHTML = html;
          
          // 恢复目录显示
          const hiddenElements = document.querySelectorAll('[data-encrypted-hidden="true"]');
          hiddenElements.forEach(el => {
            el.style.cssText = "";
            el.removeAttribute('data-encrypted-hidden');
          });
          
          // 恢复页面标题左对齐
          const pageTitle = document.querySelector("h1");
          if (pageTitle) {
            pageTitle.style.textAlign = "";
          }
          
          // 移除 noindex meta 标签
          const noindexMeta = document.querySelector("meta[name='robots'][content*='noindex']");
          if (noindexMeta) {
            noindexMeta.setAttribute("content", "index, follow");
          }
          
          // 移除搜索排除标记
          document.documentElement.removeAttribute('data-search-exclude');
          const searchExcludeMeta = document.querySelector("meta[name='starlight:search']");
          if (searchExcludeMeta) {
            searchExcludeMeta.remove();
          }
          
          // 停止所有监控和定时器
          if (observer) observer.disconnect();
          if (hideTOCInterval) {
            clearInterval(hideTOCInterval);
            hideTOCInterval = null;
          }
        } catch (e) {
          // 如果自动解密失败，显示加密界面
          article.classList.add("show");
          article.style.opacity = "1";
          article.style.visibility = "visible";
          article.style.transition = "";
          article.style.display = "flex";
          input.value = autoDecryptPassword;
        }
      })();
    }
  }

  function setItemWithExpire(key, value, ttl) {
    const item = { value: value, expire: new Date().getTime() + ttl * 1000 };
    localStorage.setItem(key, JSON.stringify(item));
  }

  function getItemWithExpire(key) {
    const itemStr = localStorage.getItem(key);
    if (!itemStr) return null;

    const item = JSON.parse(itemStr);
    if (new Date().getTime() > item.expire) {
      localStorage.removeItem(key);
      return null;
    }
    return item.value;
  }

  // 延迟初始化，确保页面先渲染
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      setTimeout(prepare, 0);
    });
  } else {
    setTimeout(prepare, 0);
  }

  // Astro 页面切换时重新初始化
  document.addEventListener("astro:after-swap", () => {
    // 清除初始化标记，允许重新初始化
    const encryption = document.getElementById("encryption");
    if (encryption) {
      encryption.dataset.initialized = "false";
    }
    setTimeout(prepare, 0);
  });
</script>

